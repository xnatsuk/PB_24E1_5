create extension if not exists "moddatetime" with schema "extensions";

drop type if exists "public"."reputation";
create type "public"."reputation" as enum ('Legendary', 'Veteran', 'Villager', 'Sprout');

-- create sequence "public"."id_sequence";

-- TABLES

create table if not exists
  public.users (
    id uuid not null ,
    username character varying(100) not null,
    avatar_url character varying(255) null,
    score bigint not null default '0'::bigint,
    reputation public.reputation not null default 'Sprout'::reputation,
    constraint users_pkey primary key (id),
    constraint users_username_key unique (username),
    constraint users_id_fkey foreign key (id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

create index on "public"."users" using btree (id, username);
alter table "public"."users" enable row level security;


create table
  public.posts (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    updated_at timestamp with time zone not null default now(),
    title character varying(255) not null,
    description character varying(255) null,
    likes bigint not null default '0'::bigint,
    user_id uuid not null default auth.uid (),
    content text not null,
    constraint posts_pkey primary key (id),
    constraint posts_user_id_fkey foreign key (user_id) references users (id)
  ) tablespace pg_default;

create index on "public"."posts" using btree (id, user_id);
alter table "public"."posts" enable row level security;


create table
  public.messages (
    id bigint generated by default as identity,
    user_id uuid not null default auth.uid (),
    post_id bigint not null,
    content text not null,
    created_at timestamp with time zone not null default now(),
    constraint messages_pkey primary key (id),
    constraint messages_user_id_fkey foreign key (user_id) references users (id),
    constraint messages_post_id_fkey foreign key (post_id) references posts (id)
  ) tablespace pg_default;

create index on "public"."messages" using btree (id, user_id, post_id);
alter table "public"."messages" enable row level security;


-- begin;
--   drop publication if exists supabase_realtime;
--   create publication supabase_realtime;
-- commit;
-- alter publication supabase_realtime add table posts;
-- alter publication supabase_realtime add table messages;
-- alter publication supabase_realtime add table users;


-- FUNCTIONS
set check_function_bodies = off;
-- This trigger automatically creates a user entry when a new user signs up via Supabase Auth.
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.users (id, username, avatar_url)
  values (new.id, new.raw_user_meta_data->>'username', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;


-- -- Set up Storage!
-- insert into storage.buckets (id, name)
--   values ('avatars', 'avatars');
--
-- -- Set up access controls for storage.
-- create policy "Only Users can view their avatar on storage"
--     on storage.objects
--     for select to authenticated
--     using ((select auth.uid()) = owner);
--
--
-- create policy "Users can upload an avatar."
--     on storage.objects
--     for insert to authenticated
--     with check (bucket_id = 'avatars');
--
--
-- create policy "Users can update their own avatar."
--     on storage.objects
--     for update to authenticated
--     using ((select auth.uid()) = owner);


create or replace function public.increment_score()
 returns trigger
 language plpgsql
    security definer
as $function$
begin
  if TG_OP = 'INSERT' then
    if TG_TABLE_NAME = 'posts' then
      update users
      set score = score + 1
      where id = new.user_id;
    elsif TG_TABLE_NAME = 'messages' then
      update users
      set score = score + 1
      where id = new.user_id;
    end if;
  elsif TG_OP = 'UPDATE' and new.likes > old.likes then
    if TG_TABLE_NAME = 'posts' then
      update users
      set score = score + 1
      -- so users can't like their own posts;
      where posts.user_id != auth.uid();
    end if;
  end if;
  return new;
end;
$function$
;


-- TRIGGERS

create or replace trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

create or replace  trigger increment_score_trigger_create_message
    after insert on public.messages
    for each row execute procedure public.increment_score();

create or replace  trigger increment_score_trigger_create_post
    after insert on public.posts
    for each row execute procedure public.increment_score();

create or replace trigger increment_score_trigger_on_like
    before update on public.posts
    for each row execute procedure public.increment_score();

create or replace trigger handle_updated_at
    before update on public.posts
    for each row execute procedure moddatetime('updated_at');

create or replace trigger handle_updated_at
    before update on public.messages
    for each row execute procedure moddatetime('updated_at');


-- POLICIES
create policy "Enable insert for authenticated users only"
    on "public"."messages" for insert to authenticated
    with check ((select auth.uid()) = user_id);


create policy "Enable read access for all users"
    on "public"."messages" for select
    using (true);


create policy "Users can delete their own messages."
    on "public"."messages" for delete to authenticated
    using ((select auth.uid()) =  user_id);


create policy "Users can update their own messages."
    on "public"."messages" for update to authenticated
    using ((select auth.uid()) =  user_id);


create policy "Authenticated users can insert posts"
    on "public"."posts" for insert to authenticated
    with check ((select auth.uid()) =  user_id);


create policy "Authors can delete their own posts"
    on "public"."posts" for delete to authenticated
    using ((select auth.uid()) =  user_id);


create policy "Authors can update their own posts"
    on "public"."posts" for update to authenticated
    using ((select auth.uid()) =  user_id);


create policy "Everyone can read posts"
    on "public"."posts" for select
    using (true);


create policy "Public users are viewable by everyone."
    on "public"."users" for select
    using (true);


create policy "Users can insert their own profile."
    on "public"."users" for insert to authenticated
    with check ((select auth.uid()) = users.id);


create policy "Users can update own profile."
    on "public"."users" for update to authenticated
    using ((select auth.uid()) = users.id);


-- grant delete on table "public"."posts" to "authenticated";
-- grant insert on table "public"."posts" to "authenticated";
-- grant references on table "public"."posts" to "authenticated";
-- grant select on table "public"."posts" to "authenticated";
-- grant trigger on table "public"."posts" to "authenticated";
-- grant truncate on table "public"."posts" to "authenticated";
-- grant update on table "public"."posts" to "authenticated";
-- grant delete on table "public"."posts" to "service_role";
-- grant insert on table "public"."posts" to "service_role";
-- grant references on table "public"."posts" to "service_role";
-- grant select on table "public"."posts" to "service_role";
-- grant trigger on table "public"."posts" to "service_role";
-- grant truncate on table "public"."posts" to "service_role";
-- grant update on table "public"."posts" to "service_role";
-- grant select on table "public"."posts" to "anon";
-- grant select on table "public"."messages" to "anon";
-- grant delete on table "public"."messages" to "authenticated";
-- grant insert on table "public"."messages" to "authenticated";
-- grant references on table "public"."messages" to "authenticated";
-- grant select on table "public"."messages" to "authenticated";
-- grant trigger on table "public"."messages" to "authenticated";
-- grant truncate on table "public"."messages" to "authenticated";
-- grant update on table "public"."messages" to "authenticated";
-- grant delete on table "public"."messages" to "service_role";
-- grant insert on table "public"."messages" to "service_role";
-- grant references on table "public"."messages" to "service_role";
-- grant select on table "public"."messages" to "service_role";
-- grant trigger on table "public"."messages" to "service_role";
-- grant truncate on table "public"."messages" to "service_role";
-- grant update on table "public"."messages" to "service_role";